use anyhow::Result;
use sp1_sdk::{ProverClient, SP1Stdin, SP1ProofWithPublicValues};
use std::time::{Duration, Instant};
use tracing::{info, error, warn};

mod types;
mod aptos_client;
mod ethereum_client;

use types::*;
use aptos_client::AptosClient;
use ethereum_client::EthereumClient;

/// The compiled guest program ELF binary
/// This is generated by build.rs and includes the RISC-V executable
const GUEST_ELF: &[u8] = include_bytes!("../../target/riscv32im-unknown-none-elf/release/diem-guest");

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            std::env::var("RUST_LOG")
                .unwrap_or_else(|_| "info".to_string())
        )
        .init();

    info!("üöÄ Starting Diem SP1 Prover Service");
    info!("üì¶ Guest program size: {} bytes", GUEST_ELF.len());

    // Load configuration from environment
    dotenv::dotenv().ok();
    let config = Config::from_env()?;
    info!("‚úÖ Configuration loaded");

    // Initialize clients
    info!("Connecting to Aptos RPC: {}", config.aptos_rpc);
    let aptos_client = AptosClient::new(&config.aptos_rpc)?;

    info!("Connecting to Ethereum RPC...");
    let ethereum_client = EthereumClient::new(
        &config.ethereum_rpc,
        &config.contract_address,
        &config.private_key,
    ).await?;

    info!("‚úÖ All clients initialized");
    info!("üìä Light client contract: {}", config.contract_address);

    // Initialize SP1 prover
    let prover_client = ProverClient::new();
    info!("‚úÖ SP1 prover initialized");

    // Main prover loop
    info!("üîÑ Starting main loop (poll every {} seconds)", config.poll_interval);
    let mut interval = tokio::time::interval(Duration::from_secs(config.poll_interval));

    loop {
        interval.tick().await;

        match process_update(&aptos_client, &ethereum_client, &prover_client).await {
            Ok(_) => {},
            Err(e) => {
                error!("‚ùå Update failed: {:#}", e);
                // Continue running despite errors
                continue;
            }
        }
    }
}

/// Process a single state update
async fn process_update(
    aptos: &AptosClient,
    ethereum: &EthereumClient,
    prover: &ProverClient,
) -> Result<()> {
    // 1. Get current state from Ethereum
    let current_version = ethereum.get_current_version().await?;
    info!("üìç Current Ethereum version: {}", current_version);

    // 2. Check for new Aptos state
    let latest_version = aptos.get_latest_version().await?;
    info!("üìç Latest Aptos version: {}", latest_version);

    if latest_version <= current_version {
        info!("‚úì No new updates available");
        return Ok(());
    }

    info!("üì• New update available: {} ‚Üí {}", current_version, latest_version);

    // 3. Fetch state proof from Aptos
    info!("‚¨áÔ∏è  Fetching state proof from Aptos...");
    let state_proof = aptos.get_state_proof(current_version, latest_version).await?;
    info!("‚úÖ State proof fetched");
    info!("   - Validators: {}", state_proof.validators.len());
    info!("   - Signatures: {}", state_proof.signatures.len());

    // 4. Generate SP1 proof
    info!("üîÆ Generating SP1 proof...");
    let start = Instant::now();

    let (proof, public_values) = generate_sp1_proof(prover, &state_proof)?;

    let elapsed = start.elapsed();
    info!("‚úÖ Proof generated in {:.2}s", elapsed.as_secs_f64());
    info!("üì¶ Proof size: {} bytes", proof.bytes().len());

    // 5. Submit proof to Ethereum
    info!("üì§ Submitting proof to Ethereum...");
    let tx_hash = ethereum
        .submit_proof(proof.bytes(), &public_values)
        .await?;

    info!("‚úÖ Proof submitted successfully!");
    info!("   Transaction hash: {:#x}", tx_hash);
    info!("   Updated: {} ‚Üí {}", current_version, latest_version);

    Ok(())
}

/// Generate an SP1 proof for the given state proof
fn generate_sp1_proof(
    client: &ProverClient,
    state_proof: &AptosStateProof,
) -> Result<(SP1ProofWithPublicValues, Vec<u8>)> {
    // Prepare input for the guest program
    let mut stdin = SP1Stdin::new();
    stdin.write(state_proof);

    info!("   Generating proof with SP1 zkVM...");

    // Generate the proof
    // Options:
    //   .run()        - Fast, larger proofs (~10KB)
    //   .compressed() - Balanced, medium size (~1-2KB)
    //   .groth16()    - Smallest, slowest (~256 bytes)
    let proof = client
        .prove(GUEST_ELF, stdin)
        .compressed()  // Good balance of size and speed
        .run()?;

    // Extract public values
    let public_values = proof.public_values.to_vec();

    Ok((proof, public_values))
}

/// Configuration loaded from environment variables
#[derive(Debug, Clone)]
struct Config {
    aptos_rpc: String,
    ethereum_rpc: String,
    contract_address: String,
    private_key: String,
    poll_interval: u64,
}

impl Config {
    fn from_env() -> Result<Self> {
        Ok(Self {
            aptos_rpc: std::env::var("APTOS_RPC")
                .unwrap_or_else(|_| "https://fullnode.mainnet.aptoslabs.com/v1".to_string()),
            ethereum_rpc: std::env::var("ETHEREUM_RPC")
                .map_err(|_| anyhow::anyhow!("ETHEREUM_RPC environment variable not set"))?,
            contract_address: std::env::var("CONTRACT_ADDRESS")
                .map_err(|_| anyhow::anyhow!("CONTRACT_ADDRESS environment variable not set"))?,
            private_key: std::env::var("PRIVATE_KEY")
                .map_err(|_| anyhow::anyhow!("PRIVATE_KEY environment variable not set"))?,
            poll_interval: std::env::var("POLL_INTERVAL")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or(60),
        })
    }
}
